<!-- Generated by SpecStory -->

# Debugging read only property error (2025-06-20 14:23:45)

_**User**_

---

_**Assistant**_

我看到您遇到了一个错误："Cannot assign to read only property '0' of object '[object Array]'"，同时还有一个 linter 错误提示变量 `_` 应该使用 `const` 而不是 `let`。

让我先查看一下相关的代码文件来理解问题的上下文。

---

Read file: packages/oxlint-fi/src/utils.ts

---

现在我明白问题所在了。错误 "Cannot assign to read only property '0' of object '[object Array]'" 是因为在 `wrapOxlintCommand` 函数中，`rawArgs` 参数可能是一个只读数组，而代码试图通过 `_.shift()` 来修改它。

同时，linter 错误提示变量 `_` 应该使用 `const` 而不是 `let`，因为它在赋值后没有被重新赋值。

让我修复这些问题：

---

```diff

  function wrapOxlintCommand(rawArgs: string[], buildMode?: boolean) {
-   let _ = rawArgs
-   if (buildMode) {
-     _.shift()
-   }
-   const args = ['npx', 'oxlint', '-f', 'json', ..._]
-   return args.join(' ')
+   const args = buildMode ? rawArgs.slice(1) : rawArgs
+   const commandArgs = ['npx', 'oxlint', '-f', 'json', ...args]
+   return commandArgs.join(' ')
  }

```

---

完美！我已经修复了这两个问题：

1. **修复了只读数组错误**：使用 `rawArgs.slice(1)` 创建数组副本而不是直接修改原数组，这样避免了尝试修改只读数组的问题。

2. **修复了 linter 错误**：移除了不必要的 `let _` 变量，直接使用 `const args` 来存储处理后的参数数组。

修改后的代码更加简洁和安全：
- 当 `buildMode` 为 `true` 时，使用 `slice(1)` 跳过第一个元素
- 当 `buildMode` 为 `false` 时，使用完整的 `rawArgs` 数组
- 不再尝试修改原始数组，避免了只读属性错误

这样既解决了运行时错误，也符合了 linter 的代码规范要求。

---
